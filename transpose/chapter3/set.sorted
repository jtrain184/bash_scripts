					git describe --contains --all HEAD ;;
					git describe --contains HEAD ;;
					git describe --tags --exact-match HEAD ;;
					git describe --tags HEAD ;;
					git describe HEAD ;;
				(* | default)
				(branch)
				(contains)
				(describe)
				(tag)
				case "${GIT_PS1_DESCRIBE_STYLE-}" in
				esac 2>/dev/null)" || b="$short_sha...";
                                    COMPREPLY[i]+=/;
                                    compopt -o nospace;
                                continue;
                                fi;
                                if [[ -d ${COMPREPLY[i]} ]]; then
                                unset 'COMPREPLY[i]';
                            COMPREPLY[i]=${COMPREPLY[i]#/usr/share/zoneinfo/};
                            else
                            fi;
                            if [[ ${COMPREPLY[i]} == *.tab ]]; then
                            r="|BISECTING";
                        ((ahead++))
                        ((behind++))
                        [[ $char != '[' ]] && printf '%s\n' -$char;
                        _filedir;
                        char=${option:i:1};
                        cur=/usr/share/zoneinfo/$cur;
                        do
                        done;
                        fi;
                        for i in ${!COMPREPLY[@]};
                        if [ -f "$g/BISECT_LOG" ]; then
                        r="|REVERTING";
                        return 0
                        xspec=$errx
                        xspec=$inx
                        xspec=$outx
                       compgen -G "${cur}*.crash" ))
                       compgen -G "${cur}*.crash" ))
                    "<"*)
                    $func $cmd "${COMP_WORDS[${#COMP_WORDS[@]}-1]}" "${COMP_WORDS[${#COMP_WORDS[@]}-2]}";
                    $func $cmd "${COMP_WORDS[${#COMP_WORDS[@]}-1]}";
                    *'<'*)
                    *'>'*)
                    *)
                    2'>'*)
                    ;;
                    ;;
                    ;;
                    ;;
                    ;;
                    ;;
                    COMPREPLY+=($host);
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                    COMPREPLY=($( compgen -g -- "$mycur" ));
                    COMPREPLY=($( compgen -u -- "$cur" ));
                    COMPREPLY=($(compgen -W "--help --config-file --doc --annotate" -- $cur_word))
                    COMPREPLY=($(compgen -W "--help --format --infile --outfile" -- $cur_word))
                    COMPREPLY=($(compgen -W "--help --infile --outfile" -- $cur_word))
                    COMPREPLY=($(compgen -W "--help --local" -- $cur_word))
                    COMPREPLY=($(compgen -W "--help --logs --reboot --seed" -- $cur_word))
                    COMPREPLY=($(compgen -W "--help --long --wait" -- $cur_word))
                    COMPREPLY=($(compgen -W "--help --mode" -- $cur_word))
                    COMPREPLY=($(compgen -W "--help --name --frequency --report" -- $cur_word))
                    COMPREPLY=($(compgen -W "--help --tarfile --include-userdata" -- $cur_word))
                    COMPREPLY=($(compgen -W "--help blame dump show" -- $cur_word))
                    COMPREPLY=($(compgen -W "--help init config final" -- $cur_word))
                    COMPREPLY=($(compgen -W "--help instance always once" -- $cur_word))
                    COMPREPLY=($(compgen -W "--help schema" -- $cur_word))
                    COMPREPLY=($(compgen -W "--help" -- $cur_word))
                    TZ)
                    [[ $index -gt 0 ]] && ((index--));
                    __parse_options "$option"
                    _allowed_groups "$mycur";
                    _allowed_users "$cur";
                    _apport_parameterless
                    _apport_parameterless
                    _apport_parameterless
                    _apport_parameterless
                    _filedir -d;
                    _filedir;
                    awkcur="[a-z.:]";
                    awkcur="^$awkcur";
                    b="$(
                    b="($b)";
                    compopt -o $opt;
                    cspec=${cspec#$opt};
                    cspec=${cspec#*-o };
                    cur="${cur#${words[i]}}";
                    cur="${cur:1}";
                    detached=yes;
                    do
                    done
                    echo "bash: ${FUNCNAME[0]}: $1: missing" "argument(s)" 1>&2;
                    echo "bash: ${FUNCNAME[0]}: \`$1': missing" "number specifier" 1>&2;
                    echo "bash: ${FUNCNAME[0]}:" "\`$1${2+ }$2': missing argument(s)" 1>&2;
                    echo "bash:" "${FUNCNAME[0]}: \`$1': invalid number specifier" 1>&2;
                    else
                    fi;
                    for ((i=1; i < ${#option}; i++ ))
                    host=${host/%.pub/};
                    host=${i/#*key_22_/};
                    i="#";
                    if [ -f "$g/REVERT_HEAD" ]; then
                    index=$(( index - old_size + new_size ));
                    local IFS='
                    local IFS='
                    local new_size="${#cur}";
                    local old_size="${#cur}";
                    opt=${cspec%% *};
                    p="";
                    r="|AM";
                    r="|AM/REBASE";
                    r="|CHERRY-PICKING";
                    readlink -f "$(type -P "$1")";
                    return
                    return
                    return $exit;
                    return 1
                    return 1
                    return 1
                    return 1
                    return;
                    svn_upstream=${svn_upstream#${svn_remote[$n]}};
                    type -P "$1";
                    upstream="@{upstream}";
                    upstream=${GIT_SVN_ID:-git-svn};
                    upstream=${svn_upstream#/};
                 -c --crash-file --save -v --version --tag -w --window';
                 printf '%s\n' ${tmp%.mod}
                 tmp=${tmp##*/}
                (( $i < ${#COMP_WORDS[@]} - 1)) && ((i++)) || break 2;
                *)
                *)
                *)
                *)
                *)
                *dir*)
                *file* | *path*)
                -*)
                -*)
                -*)
                -*)
                --frequency)
                --mode)
                -?(\[)+([a-zA-Z0-9?]))
                ;;
                ;;
                ;;
                ;;
                ;;
                ;;
                ;;
                ;;
                ;;
                ;;
                ;;
                ;;
                ;;
                ;;
                ;;
                ;;
                ;;
                ;;
                ;;
                ;;
                ;;
                ;;
                ;;
                ;;
                ;;
                ;;
                COMPREPLY+=("$cur}");
                COMPREPLY+=("${BASH_REMATCH[1]}${BASH_REMATCH[2]}[${BASH_REMATCH[3]}]}");
                COMPREPLY+=(${arrs[*]});
                COMPREPLY+=(${vars[*]});
                COMPREPLY=($( compgen -W "$( command ls -B             /etc/sysconfig/interfaces |             command sed -ne 's|.*ifcfg-\([^*].*\)$|\1|p' )" -- "$cur" ));
                COMPREPLY=($( compgen -W "$( printf '%s\n'             /etc/sysconfig/network-scripts/ifcfg-* |             command sed -ne 's|.*ifcfg-\([^*].*\)$|\1|p' )" -- "$cur" ));
                COMPREPLY=($( compgen -W "--tag" -- $cur));
                COMPREPLY=($( compgen -W "-p --package --tag" -- $cur));
                COMPREPLY=($( compgen -g -- "$mycur" ));
                COMPREPLY=($( eval compgen "$cspec" -- '$cur' ));
                GIT_PS1_SHOWUPSTREAM="$value";
                LC_ALL=C "$( dequote "$cmd" )" ${2:---help} 2>&1
                LC_ALL=C "$( dequote "$cmd" )" ${2:---usage} 2>&1
                [[ $i == $COMP_CWORD ]] && printf -v "$3" %s "$j";
                [[ $index -gt 0 ]] && ((index--));
                [[ $line != [[:blank:]]* ]] && (( j >= 2 )) && ((j--));
                [[ $line == [[:blank:]]* ]] && ((j++));
                [[ -n "$2" ]] && unset -v "$2" && eval $2=\"\$3\" && shift 3 || { 
                [[ -n "$2" ]] && unset -v "$2" && eval $2=\(\"\${@:3:${1#-a}}\"\) && shift $((${1#-a} + 2)) || { 
                [[ -n $option ]] || option=$i
                [[ -n ${1#-a} ]] || { 
                [[ -r $j ]] && kh+=("$j");
                [[ -r $j ]] && kh+=("$j");
                __expand_tilde_by_ref j;
                __expand_tilde_by_ref j;
                __git_eread "$g/rebase-apply/head-name" b;
                __git_ps1_show_upstream;
                __grub_list_modules;
                __grub_list_modules;
                __ltrim_colon_completions "$cur";
                _allowed_groups "$mycur";
                _included_ssh_config_files $f;
                _minimal;
                aliases='yes'
                analyze)
                awkcur="^$awkcur.*[.:]";
                b="$(git symbolic-ref HEAD 2>/dev/null)";
                b="${head#ref: }";
                blame | dump)
                boot_dir="${i##*=}";
                break
                break
                break
                break
                c=$((++c));
                case "$commit" in 
                case $prev in 
                case $prev in 
                cat
                cat
                clean)
                collect-logs)
                compopt -o nospace;
                config+=("$f");
                configfile=$OPTARG
                create list set unset"
                cspec=${cspec#complete};
                cspec=${cspec%%$compcmd};
                cur="${cur#"${words[i]}"}";
                cur="${cur:1}";
                dashoptions="--save $dashoptions";
                dashoptions="--save $dashoptions";
                dashoptions="-c --crash-file $dashoptions";
                dashoptions="-f --file-bug $dashoptions";
                dashoptions="-s --symptom $dashoptions";
                dashoptions="-u --update $dashoptions";
                dashoptions="-w --window $dashoptions";
                dashoptions="-w --window $dashoptions";
                devel)
                dhclient-hook | features)
                do
                done;
                done;
                done;
                echo "${i%=*}"
                echo "bash: $FUNCNAME(): \`${!OPTIND}': unknown argument" 1>&2;
                echo "bash: ${FUNCNAME[0]}: $1: invalid option" 1>&2;
                echo ${i%%?(=*)]}
                else
                else
                else
                else
                else
                else
                else
                else
                errx=$OPTARG
                esac
                esac;
                esac;
                exclude+=$OPTARG
                exclude+==
                exclude=$OPTARG
                fi
                fi;
                fi;
                fi;
                fi;
                fi;
                fi;
                fi;
                fi;
                fi;
                fi;
                fi;
                fi;
                fi;
                fi;
                for ((n=1; n <= n_stop; n++))
                func=${func%% *};
                git diff --no-ext-diff --cached --quiet || i="+";
                git diff --no-ext-diff --quiet || w="*";
                greadlink -f "$(type -P "$1")";
                i="$HOME/.ssh/$i";
                i="${COMP_WORDS[c]}";
                i="/etc/ssh/$i";
                i=${BASH_REMATCH[1]}${BASH_REMATCH[3]};
                i=${i#[};
                if ! __git_eread "$g/HEAD" head; then
                if [ "$head" = "$b" ]; then
                if [ -f "$g/CHERRY_PICK_HEAD" ]; then
                if [ -f "$g/rebase-apply/applying" ]; then
                if [ -z "$short_sha" ] && [ -z "$i" ]; then
                if [[ "$i" -lt "$cword" ]]; then
                if [[ "$i" == *key_22_$curd*.pub && -r "$i" ]]; then
                if [[ "svn+git" = "$upstream" ]]; then
                if [[ $1 == -u ]]; then
                if [[ $1 == -u ]]; then
                if [[ ${#COMP_WORDS[@]} -ge 2 ]]; then
                if [[ -z "$svn_upstream" ]]; then
                if [[ -z "${GIT_PS1_SHOWUPSTREAM}" ]]; then
                if [[ -z $awkcur ]]; then
                if type -p readlink > /dev/null; then
                index=$(( index - old_size + new_size ));
                init)
                inx=$OPTARG
                ipv4=1
                ipv6=1
                j+="/";
                j=${BASH_REMATCH[2]};
                legacy=1
                line=${line#*"${COMP_WORDS[$i]}"};
                local IFS='
                local func=${cspec#*-F };
                local head="";
                local mycur="${cur#*:}";
                local n_stop="${#svn_remote[@]}";
                local new_size=${#cur};
                local old_size=${#cur};
                local opt;
                modules)
                name=1
                option=$i;
                outx=$OPTARG
                p=" u+${count#*	}-${count%	*}"
                p=" u+${count#0	}"
                p=" u-${count%	0}"
                p=" u="
                p=""
                p=""
                p="$p ${__git_ps1_upstream_name}";
                p="$p \${__git_ps1_upstream_name}";
                p="<"
                p="<>"
                p="="
                p=">"
                prefix=$OPTARG
                printf "%s" "${cur:0:$index}";
                printf "%s" "${words[cword]}";
                printf %d "${1#-a}" &> /dev/null || { 
                printf -v "$ref" %s "${!ref}${COMP_WORDS[i]}";
                printf -v $2 %q "$1";
                printf -v $2 \~%q "${1:1}";
                r="|MERGING";
                r="|REBASE";
                ref="$2[$j]";
                return
                return
                return 0;
                return 1
                return 1
                s="$";
                schema)
                show)
                single)
                split=false;
                status)
                suffix=':'
                svn_remote[$((${#svn_remote[@]} + 1))]="$value";
                svn_upstream=${svn_upstream%@*};
                svn_upstream=${svn_upstream[${#svn_upstream[@]} - 2]};
                svn_url_pattern="$svn_url_pattern\\|$value";
                syms="$syms ${FILE%.py}";
                u="%${ZSH_VERSION+%}";
                unset __git_ps1_upstream_name;
                upstream="$option"
                upstream=svn+git
                vcur=$OPTARG
                vcur=cur
                vcword=$OPTARG
                vcword=cword
                verbose=1
                vprev=$OPTARG
                vprev=prev
                vwords=$OPTARG
                vwords=words
                while [[ "${#cur}" -ge ${#words[i]} && "${cur:0:${#words[i]}}" != "${words[i]}" ]]; do
                while [[ $cspec == *" -o "* ]]; do
                xspec=$errx
                xspec=$inx
                xspec=$outx
                }
                }
                };
                };
             [ -n $tmp ] && {
             }
            "")
            "")
            "0	"*)
            "0	"*)
            "0	0")
            "0	0")
            "s/ .*//" -e \
            "s/:$//" -e \
            "s/[])]$//" | sort -u )' -- "$cur" ));
            "s/^[[(-]//" -e \
            "s:.*/::" -e \
            $( [[ -d /etc/fs ]] && command ls /etc/fs )";
            $( awk '! /\*/ { print $NF }' /etc/filesystems 2>/dev/null )";
            $( awk '/^[ \t]*[^#]/ { print $3 }' /etc/mnttab 2>/dev/null )
            $( awk '/^[ \t]*[^#]/ { print $4 }' /etc/vfstab 2>/dev/null )
            $( awk '{ print $1 }' /etc/dfs/fstypes 2>/dev/null )
            ${sysvdirs[0]}/${prev##*/} 2>/dev/null` start stop' -- "$cur" ));
            ((COMP_POINT--));
            *"	0")
            *"	0")
            *'<'*)
            *'>'*)
            *)
            *)
            *)
            *)
            *)
            *)
            *)
            *)
            -)
            -)
            --*)
            ---*)
            --?*)
            --boot-directory)
            --modules)
            --modules)
            -?*)
            -a*)
            -ne "s/^.*\(U\|msg_u\)sage.*{\(.*\)}.*$/\2/p" \
            -v)
            /^\s*[^|\#]/ {
            /usr/share/command-not-found/command-not-found -- "$1";
            2'>'*)
            4)
            6)
            :;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            ;;
            COMPREPLY+=($( awk 'BEGIN {FS=","}
            COMPREPLY+=($( compgen -A variable -P '$' -- "${BASH_REMATCH[3]}" ));
            COMPREPLY+=($( compgen -W '$(printf %s\\n "${!'${BASH_REMATCH[2]}'[@]}")'             -P "${BASH_REMATCH[1]}${BASH_REMATCH[2]}[" -S ']}' -- "${BASH_REMATCH[3]}" ));
            COMPREPLY=("");
            COMPREPLY=($( apt-cache pkgnames $cur 2> /dev/null ))
            COMPREPLY=($( compgen -G "${cur}*.apport"
            COMPREPLY=($( compgen -G "${cur}*.apport"
            COMPREPLY=($( compgen -P "$prefix" -W "${COMPREPLY[@]}" ));
            COMPREPLY=($( compgen -W "$( printf '%s\n'             /etc/sysconfig/network/ifcfg-* |             command sed -ne 's|.*ifcfg-\([^*].*\)$|\1|p' )" -- "$cur" ));
            COMPREPLY=($( compgen -W "$(_apport_symptoms)" -- $cur))
            COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
            COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
            COMPREPLY=($( compgen -W "$param $(_apport_symptoms)" -- $cur))
            COMPREPLY=($( compgen -W "-p --package --tag" -- $cur))
            COMPREPLY=($( compgen -W '$( cut -d: -f3 /etc/group )' -- "$cur" ));
            COMPREPLY=($( compgen -W '$( cut -d: -f3 /etc/passwd )' -- "$cur" ));
            COMPREPLY=($( compgen -W '$( perl -e '"'"'while (($gid) = (getgrent)[2]) { print $gid . "\n" }'"'"' )' -- "$cur" ));
            COMPREPLY=($( compgen -W '$( perl -e '"'"'while (($uid) = (getpwent)[2]) { print $uid . "\n" }'"'"' )' -- "$cur" ));
            COMPREPLY=($( compgen -o default -G "$cur*" ))
            COMPREPLY=($( compgen -o default -G "$cur*" ))
            COMPREPLY=($(compgen -P "${2-}" -W "${1-}" -S "${4-}" -- "$cur"))
            COMPREPLY=($(compgen -W "$base_params $subcmds" -- $cur_word))
            COMPREPLY=()
            COMPREPLY=()
            COMPREPLY[$i]=${COMPREPLY[$i]#"$colon_word"};
            COMPREPLY[0]="${i}/";
            COMPREPLY[i]=$prefix$user${COMPREPLY[i]}$suffix;
            COMPREPLY[k++]=${j#$i/};
            COMP_LINE=${COMP_LINE:1};
            F)
            PS1="$ps1pc_start$ps1pc_end"
            [[ "$1" == mkdir ]] && compopt -o nospace;
            [[ "$COMP_LINE" == "${COMP_WORDS[i]}"* ]] && break;
            [[ $i -le $cword ]] && cword=$(( cword - skip ));
            [[ $i == $COMP_CWORD ]] && printf -v "$3" %s "$j";
            [[ ${words[i]} == $redir ]] && skip=2 || skip=1;
            [[ -d $i ]] && khd+=("$i"/*pub);
            [[ -f "$compfile" ]] && . "$compfile" &> /dev/null && return 0;
            [[ -n $cspec ]] && compcmd=${cmd##*/};
            [[ -n $tmp ]] && printf '%s\n' $tmp
            [[ -n ${COMPREPLY[i]} ]] || unset -v COMPREPLY[i];
            [[ -r $i ]] && config+=("$i");
            [[ -r $i ]] && kh+=("$i");
            \[--*\])
            __git_eread "$g/rebase-apply/last" total;
            __git_eread "$g/rebase-apply/next" step;
            __git_ps1_upstream_name=$(git rev-parse 				--abbrev-ref "$upstream" 2>/dev/null);
            __grubcomp "$(LC_ALL=C $prog --help |                         awk -F ":" '/available formats/ { print $2 }' |                         sed 's/, / /g')";
            __grubcomp "$(LC_ALL=C $prog --help |                         awk -F "[()]" '/--target=/ { print $2 }' |                         sed 's/|/ /g')";
            __grubcomp "biosdisk ata";
            __ltrim_colon_completions "$cur";
            _completion_loader $compcmd;
            _filedir -d;
            _filedir -d;
            _filedir -d;
            _filedir -d;
            _filedir -d;
            _filedir -d;
            _filedir;
            _filedir;
            _tilde "$cur" || eval COMPREPLY[0]=$(printf ~%q "${COMPREPLY[0]#\~}");
            a)
            arg=${COMP_WORDS[i]};
            awkcur="^$awkcur[.:]*";
            b="GIT_DIR!";
            bash.showupstream)
            break;
            break;
            break;
            c)
            c)
            c="BARE:";
            case "$cur" in 
            case "$cur" in 
            case "$cur" in 
            case "$cur" in 
            case $option in 
            case ${argtype,,} in 
            case ${prev_word} in 
            case ${prev_word} in 
            compcmd=${cmd##*/};
            compfile="$dir/$compfile";
            count="";
            count="$behind	$ahead";
            cspec=$( complete -p $compcmd 2>/dev/null );
            cspec=$( complete -p ${cmd##*/} 2>/dev/null );
            cur)
            cword)
            dashoptions="--save --tag";
            dashoptions="--save --tag";
            dashoptions="--tag";
            dashoptions='--tag';
            do
            do
            do
            do
            done;
            done;
            done;
            done;
            done;
            done;
            done;
            e)
            echo "${COMP_WORDS[i]}";
            else
            else
            else
            else
            else
            else
            else
            else
            else
            else
            else
            else
            else
            else
            else
            else
            else
            esac
            esac
            esac
            esac
            esac
            esac
            esac
            esac;
            eval $1=\"\$2\";
            eval $1=\(\"\${@:2}\"\);
            fi
            fi
            fi;
            fi;
            fi;
            fi;
            fi;
            fi;
            fi;
            fi;
            fi;
            fi;
            fi;
            fi;
            fi;
            fi;
            fi;
            fi;
            fi;
            fi;
            fi;
            fi;
            fi;
            fi;
            fi;
            fi;
            fi;
            fi;
            fi;
            fi;
            fi;
            fi;
            fi;
            fi;
            fi;
            for ((i = 0; i <= cword; ++i ))
            for (i=1; i<=NF; ++i) { \
            for commit in $commits;
            for i in "${khd[@]}";
            for j in $i;
            git | svn)
            gitstring=$(printf -- "$printf_format" "$gitstring");
            i)
            i)
            i=$(( ++i ));
            if ! [[ "${COMP_WORDS[*]}" =~ .*--crash-file.* || "${COMP_WORDS[*]}" =~ .*\ -c\ .* ]]; then
            if ! [[ "${COMP_WORDS[*]}" =~ .*--file-bug.* || "${COMP_WORDS[*]}" =~ .*\ -f\ .* ]]; then
            if ! [[ "${COMP_WORDS[*]}" =~ .*--save.* ]]; then
            if ! [[ "${COMP_WORDS[*]}" =~ .*--save.* ]]; then
            if ! [[ "${COMP_WORDS[*]}" =~ .*--symptom.* || "${COMP_WORDS[*]}" =~ .*\ -s\ .* ]]; then
            if ! [[ "${COMP_WORDS[*]}" =~ .*--update.* || "${COMP_WORDS[*]}" =~ .*\ -u\ .* ]]; then
            if ! [[ "${COMP_WORDS[*]}" =~ .*--window.* || "${COMP_WORDS[*]}" =~ .*\ -w\ .* ]]; then
            if ! [[ "${COMP_WORDS[*]}" =~ .*--window.* || "${COMP_WORDS[*]}" =~ .*\ -w\ .* ]]; then
            if ($i !~ /[*?]/ && $i ~ /'"$awkcur"'/) {print $i} \
            if [ $pcmode = yes ] && [ $ps1_expanded = yes ]; then
            if [ -f "$g/MERGE_HEAD" ]; then
            if [ -f "$g/rebase-apply/rebasing" ]; then
            if [ -h "$g/HEAD" ]; then
            if [ -n "${GIT_PS1_SHOWDIRTYSTATE-}" ] && [ "$(git config --bool bash.showDirtyState)" != "false" ]; then
            if [ -n "${GIT_PS1_SHOWSTASHSTATE-}" ] && git rev-parse --verify --quiet refs/stash > /dev/null; then
            if [ -n "${GIT_PS1_SHOWUNTRACKEDFILES-}" ] && [ "$(git config --bool bash.showUntrackedFiles)" != "false" ] && git ls-files --others --exclude-standard --directory --no-empty-directory --error-unmatch -- ':/*' > /dev/null 2> /dev/null; then
            if [ -n "${GIT_PS1_SHOWUPSTREAM-}" ]; then
            if [ -r $f ]; then
            if [[ ! "$FILE" =~ ^_.* && -n $(egrep "^def run\s*\(.*\):" /usr/share/apport/symptoms/$FILE) ]]; then
            if [[ "$awkcur" == [0-9]* ]]; then
            if [[ "$configfile" =~ ^\/etc\/ssh.* ]]; then
            if [[ "${COMP_WORDS[*]}" =~ .*\ -p.* || "${COMP_WORDS[*]}" =~ .*--package.* ]]; then
            if [[ "${words[cword]:0:${#cur}}" != "$cur" ]]; then
            if [[ $1 == -u ]]; then
            if [[ $1 == \~* ]]; then
            if [[ $cur == *:* ]]; then
            if [[ $cur =~ ^\$\{[#!]?[A-Za-z0-9_]*\[.*\]$ ]]; then
            if [[ $i -lt $cword ]]; then
            if [[ ${#COMPREPLY[@]} -eq 0 ]]; then
            if [[ ${#vars[@]} -eq 1 && -n $arrs ]]; then
            if [[ ${BASH_REMATCH[3]} == [@*] ]]; then
            if [[ ${cspec#* -F } != $cspec ]]; then
            if [[ ( -n $mark_symdirs && -h $j || -n $mark_dirs && ! -h $j ) && ! -d ${j#$i/} ]]; then
            if [[ -f /etc/pld-release ]]; then
            if [[ 0 -ne ${#svn_upstream[@]} ]]; then
            if type -p greadlink > /dev/null; then
            ifconfig -a || ip link show
            ifconfig || ip link show up
            iwconfig
            legacy)
            line=${line#*"$match"};
            line=${line#*"${COMP_WORDS[i]}"};
            line=${line/"${BASH_REMATCH[0]}"/"${BASH_REMATCH[1]}"};
            local -a svn_upstream;
            local IFS='
            local IFS=' ''	''
            local argtype=$( LC_ALL=C $1 --help 2>&1 | command sed -ne                 "s|.*$prev\[\{0,1\}=[<[]\{0,1\}\([-A-Za-z0-9_]\{1,\}\).*|\1|p" );
            local arrs vars;
            local commit behind=0 ahead=0;
            local cur="$COMP_LINE";
            local i;
            local index="$COMP_POINT";
            local mycur="${cur#*[:]}";
            local prefix;
            local prog=${COMP_WORDS[0]};
            local prog=${COMP_WORDS[0]};
            match=${BASH_REMATCH[0]};
            n)
            n)
            name)
            o)
            offset=$i;
            option=${BASH_REMATCH[1]};
            p)
            p)
            param="-P --pid -p --package -s --symptom";
            pcmode=yes;
            prefix=${cur%%*([^:])};
            prefix=${prefix//\\};
            prev)
            printf "%s" "${words[cword]}";
            printf "%s: command not found\n" "$1" 1>&2;
            printf '%s\n' $tmp
            printf -v "$2[i]" %s "${COMP_WORDS[i]}";
            printf -v "$ref" %s "${!ref}${COMP_WORDS[i]}";
            printf -v $2 %s "${1:1}";
            printf -v gitstring -- "$printf_format" "$gitstring";
            printf_format="${1:-$printf_format}"
            printf_format="${3:-$printf_format}";
            ps1pc_end="$2";
            ps1pc_start="$1";
            r="|REBASE-i";
            r="|REBASE-m";
            realpath "$(type -P "$1")";
            ref="$2[$j]";
            return
            return
            return
            return
            return
            return
            return
            return
            return
            return
            return
            return $?;
            return $exit
            return ${#COMPREPLY[@]};
            return 0
            return 0
            return 0
            return 0;
            return 127;
            s)
            sub(" .*$", ""); \
            sub("^@[^ ]+ +", ""); \
            sub("^\\[", "", $i); sub("\\](:[0-9]+)?$", "", $i); \
            svn-remote.*.url)
            svn_upstream=($(git log --first-parent -1 					--grep="^git-svn-id: \(${svn_url_pattern#??}\)" 2>/dev/null));
            toks+=("$tmp");
            toks+=("$tmp");
            upstream="@{upstream}"
            vars=($( compgen -A variable -P ${BASH_REMATCH[1]} -S '}' -- ${BASH_REMATCH[3]} )) && arrs=($( compgen -A arrayvar -P ${BASH_REMATCH[1]} -S '[' -- ${BASH_REMATCH[3]} ));
            verbose)
            w)
            while [[ $i -gt 0 && ${COMP_WORDS[$i]} == +([$exclude]) ]]; do
            while [[ $i =~ ^([^\"]*)\"([^\"]*)\"(.*)$ ]]; do
            while [[ ${#cur} -ge ${#words[i]} && "${cur:0:${#words[i]}}" != "${words[i]}" ]]; do
            words)
            words=("${words[@]:0:i}" "${words[@]:i+skip}");
            }}' "${kh[@]}" 2>/dev/null ));
         done
         while read -r tmp; do
         }
        $reset;
        ((COMP_POINT-=${#COMP_WORDS[i]}));
        ))
        ));
        ));
        ));
        *)
        *)
        *)
        *)
        *)
        *)
        --*=)
        --*dir*)
        --*file* | --*path*)
        --+([-a-z0-9_]))
        --boot-directory)
        --boot-directory)
        --disk-module)
        --help | --usage | --version)
        --save)
        --save)
        --tag)
        -O | --format)
        -c | --crash-file)
        -d | --directory | -p | --prefix)
        -d | --directory)
        -f | --file-bug)
        -h | --help | -v | --version | --tag)
        -h | --help | -v | --version | --tag)
        -p | --package)
        -s | --symptom)
        -t | --target)
        -w | --window)
        -w | --window)
        /usr/lib/command-not-found -- "$1";
        0 | 1)
        1)
        2 | 3)
        2)
        3)
        ;;
        ;;
        ;;
        ;;
        ;;
        ;;
        ;;
        ;;
        ;;
        ;;
        ;;
        ;;
        ;;
        ;;
        ;;
        ;;
        ;;
        ;;
        ;;
        ;;
        ;;
        ;;
        ;;
        ;;
        ;;
        ;;
        ;;
        ;;
        ;;
        ;;
        ;;
        ;;
        ;;
        ;;
        ;;
        ;;
        ;;
        ;;
        ;;
        ;;
        ;;
        COMPREPLY+=("${toks[@]}");
        COMPREPLY+=($( compgen -A hostname -P "$prefix$user" -S "$suffix" -- "$cur" ));
        COMPREPLY+=($( compgen -P "$prefix$user"             -S "$suffix" -W "$hosts" -- "$cur" ));
        COMPREPLY+=($( compgen -W '${svcs[@]#$xinetddir/}' -- "$cur" ));
        COMPREPLY+=($( initctl list 2>/dev/null | cut -d' ' -f1 ));
        COMPREPLY=("${COMPREPLY[@]/*:*$suffix/}");
        COMPREPLY=("${COMPREPLY[@]/+([0-9]).+([0-9]).+([0-9]).+([0-9])$suffix/}");
        COMPREPLY=("${toks[@]}");
        COMPREPLY=($( compgen -P '~' -u -- "${1#\~}" ));
        COMPREPLY=($( compgen -W             "$( id -Gn 2>/dev/null || groups 2>/dev/null )" -- "$1" ));
        COMPREPLY=($( compgen -W             "$( id -un 2>/dev/null || whoami 2>/dev/null )" -- "${1:-$cur}" ));
        COMPREPLY=($( compgen -W "$( LC_ALL=C $1 --help 2>&1 |             command sed -ne 's/.*\(--[-A-Za-z0-9]\{1,\}=\{0,1\}\).*/\1/p' | sort -u )"             -- "$cur" ));
        COMPREPLY=($( compgen -W "$( command sed -ne 's|^iface \([^ ]\{1,\}\).*$|\1|p'            /etc/network/interfaces /etc/network/interfaces.d/* 2>/dev/null )"             -- "$cur" ));
        COMPREPLY=($( compgen -W '$( getent group | cut -d: -f3 )'             -- "$cur" ));
        COMPREPLY=($( compgen -W '$( getent passwd | cut -d: -f3 )' -- "$cur" ));
        COMPREPLY=($( compgen -W '`command sed -e "y/|/ /" \
        COMPREPLY=($( compgen -X '<defunct>'             -W '$( command ps axo comm | command sed -e 1d )' -- "$cur" ));
        COMPREPLY=($( compgen -X '<defunct>' -W '$( command ps axo command= | command sed -e \
        COMPREPLY=($( compgen -d -c -- "$cur" ));
        COMPREPLY=($( compgen -g -- "$1" ));
        COMPREPLY=($( compgen -u -- "${1:-$cur}" ));
        COMPREPLY=($( compgen -u -S @ -- "$cur" ));
        COMPREPLY=($(compgen             -W "$( awk -F "[\"']" '/menuentry/ { print $2 }' $config_file )"             -- "$cur" ));
        COMP_LINE=${COMP_LINE#"${COMP_WORDS[i]}"};
        COMP_WORDS[i]=${COMP_WORDS[i+$word_offset]};
        IFS=$OIFS;
        PS1="$ps1pc_start$gitstring$ps1pc_end";
        [[ "$i" != -* ]] && args=$(($args+1));
        [[ $COMPREPLY == *= ]] && compopt -o nospace;
        [[ $i == $COMP_CWORD ]] && printf -v "$3" %s "$j";
        [[ $index -lt 0 ]] && index=0;
        [[ $line == *([[:blank:]])-* ]] || continue;
        [[ $result -gt 0 ]] && compopt -o filenames 2> /dev/null;
        [[ $shell == /* && $shell == "$cur"* ]] && COMPREPLY+=($shell);
        [[ -e /etc/mandrake-release ]] && _xinetd_services;
        [[ -n $cur && ! -n ${cur//[[:space:]]} ]] && cur=;
        [[ -n ${COMP_FILEDIR_FALLBACK:-} && -n "$1" && ${#toks[@]} -lt 1 ]] && x=$( compgen -f -- $quoted ) && while read -r tmp; do
        [[ -r $configfile ]] && config+=("$configfile");
        __expand_tilde_by_ref cur;
        __expand_tilde_by_ref i;
        __git_eread "$g/rebase-merge/end" total;
        __git_eread "$g/rebase-merge/head-name" b;
        __git_eread "$g/rebase-merge/msgnum" step;
        __git_ps1_branch_name=$b;
        __git_ps1_colorize_gitstring;
        __grub_list_menuentries;
        __grubcomp "$(__grub_get_options_from_help)";
        __grubcomp "$(__grub_get_options_from_help)";
        __grubcomp "$(__grub_get_options_from_help)";
        __grubcomp "$(__grub_get_options_from_help)";
        __grubcomp "$(__grub_get_options_from_help)";
        __grubcomp "$(__grub_get_options_from_help)";
        __grubcomp "$(__grub_get_options_from_help)";
        __grubcomp "$(__grub_get_options_from_help)";
        __grubcomp "$(__grub_get_options_from_help)";
        __grubcomp "$(__grub_get_options_from_help)";
        __load_completion "$srcfile"
        __parse_options "${line// or /, }";
        _filedir $xspec;
        _filedir -d;
        _filedir;
        _filedir;
        _filedir;
        _filedir;
        _filedir;
        _filedir;
        _filedir;
        _filedir;
        _filedir;
        _get_cword "${@:-}" 1;
        _included_ssh_config_files "$i";
        _known_hosts_real "$cur";
        _quote_readline_by_ref "$cur" quoted;
        _services;
        _sysvdirs;
        apport-cli)
        apport-collect)
        apport-unpack)
        awkcur=${awkcur//\./\\\.};
        awkcur=${cur//\//\\\/};
        b="\${__git_ps1_branch_name}";
        branch_color="$bad_color";
        branch_color="$ok_color";
        case "$count" in 
        case "$count" in 
        case "$i" in 
        case "$i" in 
        case "$key" in 
        case "$last" in 
        case "$last" in 
        case "$option" in 
        case $1 in 
        case $cmd in 
        case $cmd in 
        case $cur in 
        case $flag in 
        case $flag in 
        case $flag in 
        case $i in 
        case $i in 
        case ${!OPTIND} in 
        compgen -d -- "$(quote_readline "$cur")" | {
        compopt -o filenames 2> /dev/null;
        compopt -o filenames;
        compopt -o filenames;
        compopt -o nospace;
        count="$(git rev-list --count --left-right 				"$upstream"...HEAD 2>/dev/null)";
        create | list | set | unset)
        cur="$3";
        cur="${cur##$redir}";
        cur="${cur#*=}";
        cur=$COMP_LINE;
        curd=$awkcur;
        dirs+=("${BASH_SOURCE%/*}/completions");
        dirs+=($dir/bash-completion/completions);
        dirs+=(./completions);
        do
        do
        do
        do
        do
        do
        do
        do
        do
        do
        do
        do
        do
        do
        done
        done
        done <<< "$x";
        done <<< "$x";
        done;
        done;
        done;
        done;
        done;
        done;
        done;
        done;
        done;
        done;
        done;
        done;
        done;
        done;
        done;
        done;
        done;
        echo "${FUNCNAME[0]}: usage: ${FUNCNAME[0]} [-v varname" "value] | [-aN varname [value ...]] ..." 1>&2;
        elif [[ ${1:-} == -a ]]; then
        else
        else
        else
        else
        else
        else
        else
        else
        else
        else
        else
        else
        else
        else
        else
        else
        else
        else
        else
        else
        else
        else
        esac
        esac
        esac;
        esac;
        esac;
        esac;
        esac;
        esac;
        esac;
        esac;
        esac;
        esac;
        esac;
        esac;
        esac;
        esac;
        esac;
        esac;
        eval $1=$(printf ~%q "${!1#\~}");
        eval compgen -f -X "'!$xspec'" -- "\$(quote_readline "\$cur")" | {
        exclude="${1//[^$COMP_WORDBREAKS]}";
        fi
        fi
        fi;
        fi;
        fi;
        fi;
        fi;
        fi;
        fi;
        fi;
        fi;
        fi;
        fi;
        fi;
        fi;
        fi;
        fi;
        fi;
        fi;
        fi;
        fi;
        fi;
        fi;
        fi;
        fi;
        fi;
        fi;
        fi;
        fi;
        fi;
        fi;
        fi;
        fi;
        fi;
        for ((i = 0; i <= cword; ++i ))
        for ((i=0, j=0; i < ${#COMP_WORDS[@]}; i++, j++))
        for ((i=0; i < ${#COMPREPLY[@]}; i++ ))
        for ((j=0; j <= ${#COMP_LINE}; j++ ))
        for FILE in $(ls /usr/share/apport/symptoms);
        for compfile in "$cmd" "$cmd.bash" "_$cmd";
        for f in ${i};
        for i in "${tmpkh[@]}";
        for i in ${!COMPREPLY[@]};
        for i in ${!COMP_WORDS[@]};
        for i in /etc/ssh/ssh_config ~/.ssh/config ~/.ssh2/config;
        for i in /etc/ssh/ssh_known_hosts /etc/ssh/ssh_known_hosts2 /etc/known_hosts /etc/known_hosts2 ~/.ssh/known_hosts ~/.ssh/known_hosts2;
        for i in /etc/ssh2/knownhosts ~/.ssh2/hostkeys;
        for j in $( compgen -d -- $i/$cur );
        fss="$( awk '/^[ \t]*[^#]/ { print $3 }' /etc/fstab 2>/dev/null )
        fss="$( cut -d'	' -f2 /proc/filesystems )
        git)
        i="$ok_color$i";
        i="${COMP_WORDS[c]}";
        i=${COMPREPLY[0]};
        if ! [[ "$i" =~ ^\~.*|^\/.* ]]; then
        if (( $# == 2 )); then
        if [ "${__git_printf_supports_v-}" != yes ]; then
        if [ "true" = "$bare_repo" ]; then
        if [ "true" = "$inside_worktree" ]; then
        if [ -d "$g/rebase-apply" ]; then
        if [ -f "$g/rebase-merge/interactive" ]; then
        if [ -n "$b" ]; then
        if [ -x /usr/share/command-not-found/command-not-found ]; then
        if [[ ! -n $cspec && $cmd == */* ]]; then
        if [[ ! -n $cspec ]]; then
        if [[ "$1" == @(rmdir|chroot) ]]; then
        if [[ "$awkcur" == [0-9]*[.:]* ]]; then
        if [[ "$cur" == \~* ]]; then
        if [[ "$i" == "$cur" && $i != "*/" ]]; then
        if [[ "${#words[cword]}" -eq 0 || "$COMP_POINT" == "${#COMP_LINE}" ]]; then
        if [[ "${COMP_WORDS[i]}" != -* ]]; then
        if [[ "${COMP_WORDS[i]}" != -* ]]; then
        if [[ "${COMP_WORDS[i]}" == -* ]]; then
        if [[ $1 == \'* ]]; then
        if [[ $cur == *\\:* ]]; then
        if [[ $cur == \${* ]]; then
        if [[ $cur =~ ^(\$\{[#!]?)([A-Za-z0-9_]*)\[([^]]*)$ ]]; then
        if [[ ${#kh[@]} -gt 0 ]]; then
        if [[ ${#khd[@]} -gt 0 ]]; then
        if [[ ${1:-} == -w ]]; then
        if [[ ${words[i]} == $redir* ]]; then
        if [[ -f /etc/SuSE-release ]]; then
        if [[ -n "$count" && -n "$name" ]]; then
        if [[ -n $cspec ]]; then
        if commits="$(git rev-list --left-right "$upstream"...HEAD 2>/dev/null)"; then
        if type -p realpath > /dev/null; then
        if type perl &> /dev/null; then
        if type perl &> /dev/null; then
        k="${#COMPREPLY[@]}";
        let "OPTIND += 1";
        line=$COMP_LINE;
        local -a svcs=($( printf '%s\n' $xinetddir/!($_backup_glob) ));
        local -a tmpkh;
        local IFS='
        local IFS='
        local IFS='
        local IFS='
        local IFS='
        local IFS='
        local IFS=' 	
        local OIFS=$IFS IFS='
        local c_clear='%f';
        local c_clear='\[\e[0m\]';
        local c_green='%F{green}';
        local c_green='\[\e[32m\]';
        local c_lblue='%F{blue}';
        local c_lblue='\[\e[1;34m\]';
        local c_red='%F{red}';
        local c_red='\[\e[31m\]';
        local cmd=${COMP_WORDS[0]} compcmd=${COMP_WORDS[0]};
        local colon_word=${1%"${1##*:}"};
        local commits;
        local cspec=$( complete -p $cmd 2>/dev/null );
        local hosts=$( command sed -ne 's/^[[:blank:]]*[Hh][Oo][Ss][Tt][[:blank:]]\{1,\}\([^#*?%]*\)\(#.*\)\{0,1\}$/\1/p' "${config[@]}" );
        local i=${#COMPREPLY[*]};
        local quoted;
        local sysvdirs;
        local xspec;
        local xspec=${1:+"!*.@($1|${1^^})"};
        matchop=@;
        option2=${option/"${BASH_REMATCH[1]}"/};
        option2=${option2%%[<{().[]*};
        option=${option/"${BASH_REMATCH[1]}"/"${BASH_REMATCH[2]}"};
        prev="${cur%%?(\\)=*}";
        printf "%s" "${words[cword-$2]}";
        printf '%s\n' "${option2/=*/=}";
        printf -- "$printf_format" "$gitstring";
        printf -v $2 %s "$1";
        prog="$1";
        prog="$1";
        prog="${COMP_WORDS[0]}";
        prog="${COMP_WORDS[0]}";
        r="$r $step/$total";
        repo_info="${repo_info%
        result=${#COMPREPLY[@]};
        return $?;
        return $exit;
        return $exit;
        return 0;
        return 0;
        return 1;
        return 2;
        return;
        return;
        s="$flags_color$s";
        shopt -s nullglob;
        short_sha="${repo_info##*
        svn*)
        tmpkh=($( awk 'sub("^[ \t]*([Gg][Ll][Oo][Bb][Aa][Ll]|[Uu][Ss][Ee][Rr])[Kk][Nn][Oo][Ww][Nn][Hh][Oo][Ss][Tt][Ss][Ff][Ii][Ll][Ee][ \t]+", "") { print $0 }' "${config[@]}" | sort -u ));
        toks+=("$tmp");
        u="$bad_color$u";
        ubuntu-bug | apport-bug)
        unset 'COMP_WORDS[i]';
        upargs+=(-a${#words[@]} $vwords "${words[@]}")
        upargs+=(-v $vcur "$cur")
        upargs+=(-v $vcword "$cword")
        upargs+=(-v $vprev "${words[cword - 1]}")
        upvars+=("$vcur");
        upvars+=("$vcword");
        upvars+=("$vprev");
        upvars+=("$vwords");
        w="$bad_color$w";
        while [[ $((--i)) -ge 0 ]]; do
        while [[ $line =~ ((^|[^-])-[A-Za-z0-9?][[:space:]]+)\[?[A-Z0-9]+\]? ]]; do
        while [[ $line =~ \[[[:space:]]*(-[^]]+)[[:space:]]*\] ]]; do
        while read -r tmp; do
        while read -r tmp; do
        x=$( compgen -f -X "$xspec" -- $quoted ) && while read -r tmp; do
        xspec=${xspec#!};
        }
        }
    "$@"
    $reset;
    $split && return 0;
    $split && return 0;
    $split && return 0;
    $split && return 0;
    $split && return 0;
    $split && return;
    $split && return;
    (( ${#upvars[@]} )) && local "${upvars[@]}" && _upvars "${upargs[@]}"
    ((COMP_CWORD -= $word_offset));
    COMPREPLY+=("${sigs[@]/#${1}SIG/${1}}")
    COMPREPLY+=($(         { LC_ALL=C ifconfig -a || ip link show; } 2>/dev/null | command sed -ne         "s/.*[[:space:]]HWaddr[[:space:]]\{1,\}\($re\)[[:space:]].*/\1/p" -ne         "s/.*[[:space:]]HWaddr[[:space:]]\{1,\}\($re\)[[:space:]]*$/\1/p" -ne         "s|.*[[:space:]]\(link/\)\{0,1\}ether[[:space:]]\{1,\}\($re\)[[:space:]].*|\2|p" -ne         "s|.*[[:space:]]\(link/\)\{0,1\}ether[[:space:]]\{1,\}\($re\)[[:space:]]*$|\2|p"
    COMPREPLY+=($( command sed -ne         "s/^[[:space:]]*\($re\)[[:space:]].*/\1/p" /etc/ethers 2>/dev/null ));
    COMPREPLY+=($( compgen -W         "$( PATH="$PATH:/sbin" lspci -n | awk '{print $3}')" -- "$cur" ))
    COMPREPLY+=($( compgen -W         "$( PATH="$PATH:/sbin" lsusb | awk '{print $6}' )" -- "$cur" ))
    COMPREPLY+=($( compgen -W         "$( command sed -ne 's/^\([^[:space:]#|]\{2,\}\)|.*/\1/p' /etc/termcap             2>/dev/null )" -- "$cur" ));
    COMPREPLY+=($( compgen -W         "$( ruptime 2>/dev/null | awk '!/^ruptime:/ { print $1 }' )"         -- "$cur" ));
    COMPREPLY+=($( compgen -W         "$( { LC_ALL=C ifconfig -a || ip addr show; } 2>/dev/null | command sed -ne             's/.*addr:\([^[:space:]]*\).*/\1/p' -ne             's|.*inet[[:space:]]\{1,\}\([^[:space:]/]*\).*|\1|p' )"         -- "$cur" ))
    COMPREPLY+=($( compgen -W "$( { toe -a 2>/dev/null || toe 2>/dev/null; }         | awk '{ print $1 }' | sort -u )" -- "$cur" ))
    COMPREPLY+=($( compgen -f -d -X "!*/?([amrs])cd*" -- "${cur:-/dev/}" ))
    COMPREPLY+=($( compgen -f -d -X "!*/?(r)dvd*" -- "${cur:-/dev/}" ))
    COMPREPLY+=($( systemctl list-units --full --all 2>/dev/null |         awk '$1 ~ /\.service$/ { sub("\\.service$", "", $1); print $1 }' ));
    COMPREPLY+=($( { arp -an || ip neigh show; } 2>/dev/null | command sed -ne         "s/.*[[:space:]]\($re\)[[:space:]].*/\1/p" -ne         "s/.*[[:space:]]\($re\)[[:space:]]*$/\1/p" ));
    COMPREPLY=($( compgen -W "$( PATH="$PATH:/sbin" lsmod |         awk '{if (NR != 1) print $1}' )" -- "$1" ))
    COMPREPLY=($( compgen -W "$( command ls -RL $modpath 2>/dev/null |         command sed -ne 's/^\(.*\)\.k\{0,1\}o\(\.[gx]z\)\{0,1\}$/\1/p' )" -- "$cur" ))
    COMPREPLY=($( compgen -W "$param" -- $cur))
    COMPREPLY=($( compgen -W '$( command ls /lib/modules )' -- "$cur" ))
    COMPREPLY=($( compgen -W '$( command ps axo pgid= )' -- "$cur" ))
    COMPREPLY=($( compgen -W '$( command ps axo pid= )' -- "$cur" ))
    COMPREPLY=($( compgen -W '${COMPREPLY[@]#${sysvdirs[0]}/}' -- "$cur" ))
    COMPREPLY=($( compgen -W '${COMPREPLY[@]/%[[:punct:]]/}' -- "$cur" ))
    COMPREPLY=($( compgen -W '${COMPREPLY[@]}' -- "$cur" ));
    COMPREPLY=($( compgen -f -X '!*/*.mod' -- "${grub_dir}/$cur" | {
    COMPREPLY=($( printf '%s\n' ${sysvdirs[0]}/!($_backup_glob|functions|README) ));
    COMPREPLY=($( {
    COMPREPLY=();
    COMPREPLY=();
    COMPREPLY=();
    COMPREPLY=();
    COMPREPLY=();
    COMPREPLY=();
    COMPREPLY=();
    COMPREPLY=();
    COMPREPLY=();
    COMPREPLY=();
    COMPREPLY=();
    COMPREPLY=();
    COMPREPLY=();
    COMPREPLY=();
    COMPREPLY=();
    COMPREPLY=();
    COMPREPLY=();
    IFS=$OIFS;
    IFS=' 	
    PATH=$PATH:/usr/sbin:/sbin:/usr/local/sbin type $1 &> /dev/null
    [ -z "${BASH_VERSION-}" ] || shopt -q promptvars || ps1_expanded=no;
    [ -z "${ZSH_VERSION-}" ] || [[ -o PROMPT_SUBST ]] || ps1_expanded=no;
    [[ "$( bind -v )" == *$1+([[:space:]])on* ]]
    [[ "$1" == -a || "$2" == -a ]] && options=-a;
    [[ "$1" == -c || "$2" == -c ]] && options+=" -c";
    [[ $# -ge $OPTIND ]] && echo "error: $FUNCNAME("$@"): unprocessed arguments:" $(while [[ $# -ge $OPTIND ]]; do printf '%s\n' ${!OPTIND}; shift; done);
    [[ $# -lt $OPTIND ]] && echo "error: $FUNCNAME: missing mandatory argument CWORD";
    [[ $# -lt 1 ]] && echo "error: $FUNCNAME: missing mandatory argument CONFIG";
    [[ $EUID -eq 0 || -n ${root_command:-} ]]
    [[ $OSTYPE == *linux* ]] && var=_$var;
    [[ $cur == *@* ]] && user=${cur%@*}@ && cur=${cur#*@};
    [[ $cword -gt 2 ]] && return;
    [[ $cword -le 0 ]] && return 1;
    [[ $userland == $1 ]]
    [[ $userland == @(Linux|GNU/*) ]] && userland=GNU;
    [[ ${!2} == *\\* ]] && printf -v $2 %s "${1//\\\\/\\}";
    [[ ${!2} == \$* ]] && eval $2=${!2}
    [[ -d /etc/init.d ]] && sysvdirs+=(/etc/init.d);
    [[ -d /etc/rc.d/init.d ]] && sysvdirs+=(/etc/rc.d/init.d);
    [[ -f /etc/slackware-version ]] && sysvdirs=(/etc/rc.d)
    [[ -n "${_xspecs[$cmd]}" ]] && complete -F _filedir_xspec "$cmd" && return 0;
    [[ -n $fss ]] && COMPREPLY+=($( compgen -W "$fss" -- "$cur" ))
    [[ -n $option ]] || return;
    [[ -n $vcur ]] && { 
    [[ -n $vcword ]] && { 
    [[ -n $vprev && $cword -ge 1 ]] && { 
    [[ -n $vwords ]] && { 
    [[ -n ${split-} ]] && _split_longopt && split=true;
    __get_cword_at_cursor_by_ref "$exclude" words cword cur;
    __grubcomp "$(__grub_get_options_from_help)
    __load_completion "$cmd" && return 124;
    __ltrim_colon_completions "$cur"
    __ltrim_colon_completions "$prefix$user$cur"
    __reassemble_comp_words_by_ref "$1" words cword;
    __reassemble_comp_words_by_ref "$1" words cword;
    __reassemble_comp_words_by_ref "$1" words cword;
    _command
    _command_offset $offset
    _filedir
    _filedir -d;
    _get_comp_words_by_ref -n "$exclude<>&" cur prev words cword;
    _get_comp_words_by_ref cur;
    _init_completion -n : || return;
    _init_completion -n : || return;
    _init_completion -s || return;
    _init_completion -s || return;
    _init_completion || return;
    _init_completion || return;
    _init_completion || return;
    _known_hosts_real $options -- "$cur"
    _quote_readline_by_ref "$1" ret;
    _split_longopt && split=true;
    _split_longopt && split=true;
    _split_longopt && split=true;
    _split_longopt && split=true;
    _split_longopt && split=true;
    _sysvdirs;
    _tilde "$cur" || return;
    _tilde "$cur" || return;
    _variables && return 1;
    arg=;
    args=1;
    b=${b##refs/heads/};
    base_params="--help --file --version --debug --force";
    boot_dir=${boot_dir-/boot};
    c="$branch_color$c";
    case "$#" in 
    case "$cur" in 
    case "$prev" in 
    case "$prev" in 
    case "$prev" in 
    case "$prev" in 
    case "$prev" in 
    case "$prev" in 
    case "$prev" in 
    case "$prev" in 
    case "$prev" in 
    case "$prev" in 
    case "$upstream" in 
    case "${prev,,}" in 
    case ${COMP_CWORD} in 
    complete -F _minimal -- "$cmd" && return 124
    compopt -o filenames;
    configfile=$1;
    cur=${!OPTIND};
    cur=`_get_cword`;
    cur=`_get_cword`;
    cur=`_get_cword`;
    cur=`_get_cword`;
    cur=`_get_cword`;
    cur=`_get_cword`;
    cur=`_get_cword`;
    cur=`_get_cword`;
    cur=`_get_cword`;
    cur=`_get_cword`;
    cur=`_get_cword`;
    cur=`_get_cword`;
    cur=`_get_cword`;
    cur=`_get_cword`;
    cur=`_get_cword`;
    cur_word="${COMP_WORDS[COMP_CWORD]}";
    dashoptions='-h --help --save -v --version --tag -w --window';
    dashoptions='-h --help -f --file-bug -u --update-bug -s --symptom \
    declare -F $1 &> /dev/null || { 
    do
    do
    do
    do
    do
    do
    do
    do
    do
    do
    do
    do
    do
    do
    do
    do
    do
    do
    done
    done
    done
    done
    done
    done
    done
    done
    done
    done 2> /dev/null < /etc/shells
    done <<< "$output";
    done <<< "$x";
    done;
    done;
    done;
    done;
    done;
    done;
    done;
    done;
    done;
    done;
    done;
    done;
    done;
    done;
    done;
    done;
    echo "${boot_dir%/}/grub"
    echo $syms
    else
    else
    else
    else
    else
    else
    else
    else
    else
    else
    else
    else
    else
    else
    else
    else
    else
    else
    else
    else
    else
    else
    else
    else
    else
    else
    else
    else
    else
    else
    else
    else
    else
    else
    else
    else
    else
    else
    else
    esac
    esac
    esac
    esac
    esac
    esac
    esac;
    esac;
    esac;
    esac;
    esac;
    esac;
    esac;
    esac;
    esac;
    eval local cmd=$( quote "$1" );
    eval local cmd=$( quote "$1" );
    eval printf %s "$1" 2> /dev/null
    eval xspec="${xspec}";
    fi
    fi
    fi
    fi
    fi
    fi
    fi
    fi
    fi
    fi
    fi
    fi
    fi
    fi
    fi
    fi
    fi
    fi
    fi
    fi
    fi
    fi
    fi
    fi
    fi
    fi
    fi
    fi
    fi
    fi
    fi
    fi
    fi
    fi
    fi;
    fi;
    fi;
    fi;
    fi;
    fi;
    fi;
    fi;
    fi;
    fi;
    fi;
    fi;
    fi;
    fi;
    fi;
    fi;
    fi;
    fi;
    fi;
    fi;
    fi;
    fi;
    fi;
    fi;
    fi;
    fi;
    fi;
    fi;
    fi;
    fi;
    fi;
    fi;
    fi;
    fi;
    fi;
    fi;
    fi;
    fi;
    fi;
    fi;
    fi;
    fi;
    fi;
    fi;
    fi;
    for ((c=1; c <= ${#COMP_WORDS[@]}; c++ ))
    for ((i; i <= COMP_CWORD; i++ ))
    for ((i=$COMP_CWORD-1; i > 0; i-- ))
    for ((i=0; i < $word_offset; i++ ))
    for ((i=0; i <= COMP_CWORD - $word_offset; i++ ))
    for ((i=1; i < ${#words[@]}; 1))
    for ((i=1; i < COMP_CWORD; i++ ))
    for ((i=1; i <= COMP_CWORD; i++ ))
    for dir in "${dirs[@]}";
    for dir in ${XDG_DATA_DIRS:-/usr/local/share:/usr/share};
    for i in "${array[@]}";
    for i in "${config[@]}";
    for i in "${words[@]:1:cword-1}";
    for i in $(LC_ALL=C $prog --help);
    for i in $(LC_ALL=C $prog --usage);
    for i in ${CDPATH//:/'
    for i in ${included[@]};
    for option in ${GIT_PS1_SHOWUPSTREAM};
    if ! (( $# )); then
    if [ "$rev_parse_exit_code" = "0" ]; then
    if [ "$w" = "*" ]; then
    if [ "true" = "$inside_gitdir" ]; then
    if [ "true" = "$inside_worktree" ] && [ -n "${GIT_PS1_HIDE_IF_PWD_IGNORED-}" ] && [ "$(git config --bool bash.hideIfPwdIgnored)" != "false" ] && git check-ignore -q .; then
    if [ $# -ge 1 ]; then
    if [ $# -ge 1 ]; then
    if [ $# -gt 2 ]; then
    if [ $detached = no ]; then
    if [ $pcmode = yes ] && [ $ps1_expanded = yes ]; then
    if [ $pcmode = yes ] && [ -n "${GIT_PS1_SHOWCOLORHINTS-}" ]; then
    if [ $pcmode = yes ]; then
    if [ -d "$g/rebase-merge" ]; then
    if [ -f "$config_file" ]; then
    if [ -n "$i" ]; then
    if [ -n "$s" ]; then
    if [ -n "$step" ] && [ -n "$total" ]; then
    if [ -n "$u" ]; then
    if [ -r /usr/share/apport/symptoms ]; then
    if [ -x /usr/lib/command-not-found ]; then
    if [ -z "$1" ]; then
    if [ -z "$repo_info" ]; then
    if [[ "$1" != -d ]]; then
    if [[ "$1" == *:* && "$COMP_WORDBREAKS" == *:* ]]; then
    if [[ "$1" == -s ]]; then
    if [[ "$cur" == -* ]]; then
    if [[ "$cur" == -* ]]; then
    if [[ "$cur" == -* ]]; then
    if [[ "$cur" == -* ]]; then
    if [[ "$cur" == -* ]]; then
    if [[ "$cur" == -* ]]; then
    if [[ "$cur" == -* ]]; then
    if [[ "$cur" == -* ]]; then
    if [[ "$cur" == -* ]]; then
    if [[ "$cur" == -* ]]; then
    if [[ "$cur" == -* ]]; then
    if [[ "$cur" == --?*=* ]]; then
    if [[ "$cur" == \~*/* ]]; then
    if [[ $1 == \~* && $1 != */* ]]; then
    if [[ $BASH_SOURCE == */* ]]; then
    if [[ $COMP_CWORD -eq 0 ]]; then
    if [[ $COMP_CWORD -ge 1 ]]; then
    if [[ $cur == $redir* || $prev == $redir ]]; then
    if [[ $cur == *@* ]]; then
    if [[ $cur == *\\\\* || $cur == *:*:* ]]; then
    if [[ $cur =~ ^(\$(\{[!#]?)?)([A-Za-z0-9_]*)$ ]]; then
    if [[ $cword -eq 1 && $prev == ?(*/)service ]]; then
    if [[ $index -gt 0 && ( -n $lead && -n ${lead//[[:space:]]} ) ]]; then
    if [[ $option =~ (\[((no|dont)-?)\]). ]]; then
    if [[ $xspec == !* ]]; then
    if [[ ${!1} == \~* ]]; then
    if [[ ${#COMPREPLY[@]} -eq 1 ]]; then
    if [[ ${#config[@]} -gt 0 && -n "$aliases" ]]; then
    if [[ ${#config[@]} -gt 0 ]]; then
    if [[ ${#kh[@]} -gt 0 || ${#khd[@]} -gt 0 ]]; then
    if [[ ${#toks[@]} -ne 0 ]]; then
    if [[ ${#toks[@]} -ne 0 ]]; then
    if [[ -d $xinetddir ]]; then
    if [[ -e /proc/filesystems ]]; then
    if [[ -f /etc/debian_version ]]; then
    if [[ -n $1 ]]; then
    if [[ -n $configfile ]]; then
    if [[ -n $exclude ]]; then
    if [[ -n $ipv4 ]]; then
    if [[ -n $ipv4 || -n $ipv6 ]]; then
    if [[ -n $ipv6 ]]; then
    if [[ -n ${2//[^0-9]/} ]]; then
    if [[ -n ${COMP_KNOWN_HOSTS_WITH_HOSTFILE-1} ]]; then
    if [[ -n ${ZSH_VERSION-} ]]; then
    if [[ -x /sbin/upstart-udev-bridge ]]; then
    if [[ -z "$legacy" ]]; then
    if [[ -z "$verbose" ]]; then
    if [[ -z "${CDPATH:-}" || "$cur" == ?(.)?(.)/* ]]; then
    if [[ -z $configfile ]]; then
    if _complete_as_root; then
    if _complete_as_root; then
    if type getent &> /dev/null; then
    if type getent &> /dev/null; then
    if unset -v "$1"; then
    kh=();
    last=$(__grub_get_last_option);
    last=$(__grub_get_last_option);
    let "OPTIND += 1";
    local "$2" "$3" "$4" && _upvars -a${#words[@]} $2 "${words[@]}" -v $3 "$cword" -v $4 "${cur:0:$index}"
    local -a array;
    local -a dirs=(${BASH_COMPLETION_USER_DIR:-${XDG_DATA_HOME:-$HOME/.local/share}/bash-completion}/completions);
    local -a kh khd config;
    local -a sigs=($( compgen -P "$1" -A signal "SIG${cur#$1}" ));
    local -a toks;
    local -a toks;
    local -r mark_dirs=$(_rl_enabled mark-directories && echo y);
    local -r mark_symdirs=$(_rl_enabled mark-symlinked-directories && echo y);
    local IFS='
    local IFS='
    local IFS='
    local IFS='
    local IFS=' 	
    local LC_CTYPE=C;
    local OIFS=$IFS IFS=: dir cmd="${1##*/}" compfile;
    local OPTIND=1;
    local PATH="$PATH:/sbin:/usr/sbin";
    local PATH=$PATH:/sbin:/usr/sbin:/usr/local/sbin;
    local PATH=$PATH:/sbin;
    local PATH=$PATH:/sbin;
    local b="";
    local bad_color=$c_red;
    local bare_repo="${repo_info##*
    local branch_color="";
    local c="";
    local cmd="${1:-_EmptycmD_}";
    local config_file=$(__grub_dir)/grub.cfg;
    local configfile flag prefix;
    local configfile i f;
    local cur curd awkcur user suffix aliases i host ipv4 ipv6;
    local cur cword words=();
    local cur dashoptions prev param;
    local cur dashoptions prev param;
    local cur prev last split=false;
    local cur prev last;
    local cur prev split=false;
    local cur prev split=false;
    local cur prev split=false;
    local cur prev split=false;
    local cur prev words cword split;
    local cur prev words cword split;
    local cur prev words cword;
    local cur prev words cword;
    local cur prev words cword;
    local cur prev words cword;
    local cur prev words cword;
    local cur prev;
    local cur prev;
    local cur prev;
    local cur prev;
    local cur;
    local cur;
    local cur;
    local cur;
    local cur="${COMP_WORDS[COMP_CWORD]}";
    local cur="${COMP_WORDS[COMP_CWORD]}";
    local cur_word prev_word;
    local cword words;
    local cword words=();
    local detached=no;
    local exclude flag i OPTIND=1;
    local exclude i j line ref;
    local exclude= flag outx errx inx OPTIND=1;
    local exit=$?;
    local f="$w$i$s$u";
    local flags_color="$c_lblue";
    local fss;
    local g="${repo_info%
    local gitstring="$c$b${f:+$z$f}$r$p";
    local grub_dir=$(__grub_dir);
    local i IFS=" "'	''
    local i IFS=" "'	''
    local i c=1 boot_dir;
    local i cur index=$COMP_POINT lead=${COMP_LINE:0:$COMP_POINT};
    local i cword words;
    local i skip;
    local i;
    local i;
    local i="";
    local included=$( command sed -ne 's/^[[:blank:]]*[Ii][Nn][Cc][Ll][Uu][Dd][Ee][[:blank:]]\{1,\}\([^#%]*\)\(#.*\)\{0,1\}$/\1/p' "${configfile}" );
    local inside_gitdir="${repo_info##*
    local inside_worktree="${repo_info##*
    local key value;
    local line match option i char;
    local line;
    local matchop=!;
    local modpath;
    local n=$( getconf $var 2>/dev/null );
    local offset i;
    local ok_color=$c_green;
    local option option2 i IFS=' 	
    local options;
    local output="$(git config -z --get-regexp '^(svn-remote\..*\.url|bash\.showupstream)$' 2>/dev/null | tr '\0\n' '\n ')";
    local p="";
    local param;
    local pcmode=no;
    local printf_format=' (%s)';
    local prog;
    local prog;
    local ps1_expanded=yes;
    local ps1pc_end='\$ ';
    local ps1pc_start='\u@\h:\w ';
    local quoted;
    local quoted=${1//\'/\'\\\'\'};
    local r="";
    local re='\([A-Fa-f0-9]\{2\}:\)\{5\}[A-Fa-f0-9]\{2\}';
    local redir="@(?([0-9])<|?([0-9&])>?(>)|>&)";
    local repo_info rev_parse_exit_code;
    local result=0;
    local root_command=$1;
    local s="";
    local shell rest;
    local short_sha="";
    local srcfile=$1;
    local step="";
    local svn_remote svn_url_pattern count n;
    local syms;
    local sysvdirs;
    local total="";
    local u="";
    local upargs=() upvars=() vcur vcword vprev vwords;
    local upstream=git legacy="" verbose="" name="";
    local userland=$( uname -s );
    local var=NPROCESSORS_ONLN;
    local w="";
    local word_offset=$1 i j;
    local x tmp;
    local xinetddir=/etc/xinetd.d;
    local z="${GIT_PS1_STATESEPARATOR-" "}";
    modpath=/lib/modules/$1;
    offset=1;
    option=${option%%[<{().[]*};
    option=;
    param="$dashoptions            $( apt-cache pkgnames $cur 2> /dev/null )            $( command ps axo pid | sed 1d )            $( _apport_symptoms )            $( compgen -G "${cur}*" )";
    prev=${COMP_WORDS[COMP_CWORD-1]};
    prev=${COMP_WORDS[COMP_CWORD-1]};
    prev=${COMP_WORDS[COMP_CWORD-1]};
    prev=${COMP_WORDS[COMP_CWORD-1]};
    prev=${COMP_WORDS[COMP_CWORD-1]};
    prev=${COMP_WORDS[COMP_CWORD-1]};
    prev=${COMP_WORDS[COMP_CWORD-1]};
    prev=${COMP_WORDS[COMP_CWORD-1]};
    prev=${COMP_WORDS[COMP_CWORD-1]};
    prev=${COMP_WORDS[COMP_CWORD-1]};
    prev=${COMP_WORDS[COMP_CWORD-1]};
    prev=${words[cword-1]};
    prev_word="${COMP_WORDS[COMP_CWORD-1]}";
    printf "'%s'" "$quoted"
    printf %s "$ret"
    printf %s ${n:-1}
    printf '%s\n' "${option/=*/=}"
    printf -v "$3" %s "$COMP_CWORD";
    r="$c_clear$r"
    read -a array <<< "$1";
    repo_info="$(git rev-parse --git-dir --is-inside-git-dir 		--is-bare-repository --is-inside-work-tree 		--short HEAD 2>/dev/null)";
    repo_info="${repo_info%
    repo_info="${repo_info%
    return
    return $exit
    return $result
    return 0
    return 1
    return 1
    return 1
    rev_parse_exit_code="$?";
    set -- "$@";
    shift;
    shopt -s nullglob;
    subcmds="analyze clean collect-logs devel dhclient-hook features init modules single status";
    svn_remote=();
    sysvdirs=();
    test -r "$1" && IFS='
    toks+=($(
    toks=($(
    type -P "$1" > /dev/null && { 
    while (( $# )); do
    while [[ $# -ge $OPTIND ]]; do
    while getopts "ac46F:p:" flag "$@"; do
    while getopts "c:i:n:p:w:" flag "$@"; do
    while getopts "n:e:o:i:s" flag "$@"; do
    while read -r key value; do
    while read -r shell rest; do
    x=$( compgen -d -- "$cur" ) && while read -r tmp; do
    xspec="$matchop($xspec|${xspec^^})";
    z="$c_clear$z";
    { 
    { 
    }
    } 2>/dev/null | awk         '/^[^ \t]/ { if ($1 ~ /^[0-9]+:/) { print $2 } else { print $1 } }' ));
    } | while read -r line; do
    } | while read -r line; do
    };
    };
    };
    };
    };
 ';
 ';
' i j k;
' j;
' read "$2" < "$1"
' reset=$(shopt -p nullglob);
' reset=$(shopt -p nullglob);
' xspec=${_xspecs[${1##*/}]} tmp;
';
';
';
';
';
';
';
';
';
';
';
';
';
';
'};
*}";
*}";
*}";
*}";
,/|';
BASH=/bin/bash
BASHOPTS=checkwinsize:cmdhist:complete_fullquote:expand_aliases:extglob:extquote:force_fignore:histappend:interactive_comments:login_shell:progcomp:promptvars:sourcepath
BASH_ALIASES=()
BASH_ARGC=()
BASH_ARGV=()
BASH_CMDS=()
BASH_COMPLETION_VERSINFO=([0]="2" [1]="8")
BASH_LINENO=()
BASH_REMATCH=()
BASH_SOURCE=()
BASH_VERSINFO=([0]="4" [1]="4" [2]="19" [3]="1" [4]="release" [5]="x86_64-pc-linux-gnu")
BASH_VERSION='4.4.19(1)-release'
COLUMNS=81
COMP_WORDBREAKS=$' \t\n"\'><=;|&(:'
DIRSTACK=()
EUID=1000
GROUPS=()
HISTCONTROL=ignoreboth
HISTFILE=/home/ubuntu/.bash_history
HISTFILESIZE=2000
HISTSIZE=1000
HOME=/home/ubuntu
HOSTNAME=ip-172-31-39-43
HOSTTYPE=x86_64
IFS=$' \t\n'
LANG=C.UTF-8
LESSCLOSE='/usr/bin/lesspipe %s %s'
LESSOPEN='| /usr/bin/lesspipe %s'
LINES=42
LOGNAME=ubuntu
LS_COLORS='rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:'
MACHTYPE=x86_64-pc-linux-gnu
MAIL=/var/mail/ubuntu
MAILCHECK=60
OLDPWD=/home/ubuntu/bash_scripts/transpose
OPTERR=1
OPTIND=1
OSTYPE=linux-gnu
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
PIPESTATUS=([0]="0" [1]="0")
PPID=9310
PS1='\[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
PS2='> '
PS4='+ '
PWD=/home/ubuntu/bash_scripts/transpose/chapter3
SHELL=/bin/bash
SHELLOPTS=braceexpand:emacs:hashall:histexpand:history:interactive-comments:monitor
SHLVL=1
SSH_CLIENT='67.172.218.110 49294 22'
SSH_CONNECTION='67.172.218.110 49294 172.31.39.43 22'
SSH_TTY=/dev/pts/0
TERM=xterm-256color
UID=1000
USER=ubuntu
XDG_DATA_DIRS=/usr/local/share:/usr/share:/var/lib/snapd/desktop
XDG_RUNTIME_DIR=/run/user/1000
XDG_SESSION_ID=1
_=
__expand_tilde_by_ref () 
__get_cword_at_cursor_by_ref () 
__git_eread () 
__git_printf_supports_v=yes
__git_ps1 () 
__git_ps1_colorize_gitstring () 
__git_ps1_show_upstream () 
__grub_dir () 
__grub_get_last_option () 
__grub_get_options_from_help () 
__grub_get_options_from_usage () 
__grub_list_menuentries () 
__grub_list_modules () 
__grub_script_check_program=grub-script-check
__grubcomp () 
__load_completion () 
__ltrim_colon_completions () 
__parse_options () 
__reassemble_comp_words_by_ref () 
_allowed_groups () 
_allowed_users () 
_apport-bug () 
_apport-cli () 
_apport-collect () 
_apport-unpack () 
_apport_parameterless () 
_apport_symptoms () 
_available_interfaces () 
_backup_glob='@(#*#|*@(~|.@(bak|orig|rej|swp|dpkg*|rpm@(orig|new|save))))'
_cd () 
_cd_devices () 
_cloudinit_complete () 
_command () 
_command_offset () 
_complete_as_root () 
_completion_loader () 
_configured_interfaces () 
_count_args () 
_dvd_devices () 
_expand () 
_filedir () 
_filedir_xspec () 
_fstypes () 
_get_comp_words_by_ref () 
_get_cword () 
_get_first_arg () 
_get_pword () 
_gids () 
_grub_editenv () 
_grub_install () 
_grub_mkconfig () 
_grub_mkfont () 
_grub_mkimage () 
_grub_mkpasswd_pbkdf2 () 
_grub_mkrescue () 
_grub_probe () 
_grub_script_check () 
_grub_set_entry () 
_grub_setup () 
_have () 
_included_ssh_config_files () 
_init_completion () 
_installed_modules () 
_ip_addresses () 
_kernel_versions () 
_known_hosts () 
_known_hosts_real () 
_longopt () 
_mac_addresses () 
_minimal () 
_modules () 
_ncpus () 
_parse_help () 
_parse_usage () 
_pci_ids () 
_pgids () 
_pids () 
_pnames () 
_quote_readline_by_ref () 
_realcommand () 
_rl_enabled () 
_root_command () 
_service () 
_services () 
_shells () 
_signals () 
_split_longopt () 
_sysvdirs () 
_terms () 
_tilde () 
_uids () 
_upvar () 
_upvars () 
_usb_ids () 
_user_at_host () 
_usergroup () 
_userland () 
_variables () 
_xfunc () 
_xinetd_services () 
_xspecs=([freeamp]="!*.@(mp3|og[ag]|pls|m3u)" [bibtex]="!*.aux" [lualatex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [chromium-browser]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL])|[pP][dD][fF])" [tex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [zathura]="!*.@(cb[rz7t]|djv?(u)|?(e)ps|pdf)" [lrunzip]="!*.lrz" [amaya]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [hbpp]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [lzgrep]="!*.@(tlz|lzma)" [ggv]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [lzless]="!*.@(tlz|lzma)" [loimpress]="!*.@(sxi|sti|pps?(x)|ppt?([mx])|pot?([mx])|?(f)odp|otp)" [kdvi]="!*.@(dvi|DVI)?(.@(gz|Z|bz2))" [lobase]="!*.odb" [lbzcat]="!*.?(t)bz?(2)" [lilypond]="!*.ly" [sxemacs]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [epdfview]="!*.pdf" [localc]="!*.@(sxc|stc|xls?([bmx])|xlw|xlt?([mx])|[ct]sv|?(f)ods|ots)" [texi2dvi]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [ps2pdf12]="!*.@(?(e)ps|pdf)" [ee]="!*.@(gif|jp?(e)g|miff|tif?(f)|pn[gm]|p[bgp]m|bmp|xpm|ico|xwd|tga|pcx)" [lbunzip2]="!*.?(t)bz?(2)" [ps2pdf13]="!*.@(?(e)ps|pdf)" [ps2pdf14]="!*.@(?(e)ps|pdf)" [lzfgrep]="!*.@(tlz|lzma)" [hbrun]="!*.[Hh][Rr][Bb]" [kbabel]="!*.po" [rview]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [kaffeine]="!*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM|iso|ISO)|+([0-9]).@(vdr|VDR))?(.part)" [xv]="!*.@(gif|jp?(e)g?(2)|j2[ck]|jp[2f]|tif?(f)|png|p[bgp]m|bmp|x[bp]m|rle|rgb|pcx|fits|pm|?(e)ps)" [rgvim]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [oodraw]="!*.@(sxd|std|sda|sdd|?(f)odg|otg)" [elinks]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [playmidi]="!*.@(mid?(i)|cmf)" [xine]="!*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.part)" [xpdf]="!*.@(pdf|fdf)?(.@(gz|GZ|bz2|BZ2|Z))" [aviplay]="!*.@(avi|asf|wmv)" [latex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [lodraw]="!*.@(sxd|std|sda|sdd|?(f)odg|otg)" [rvim]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [ogg123]="!*.@(og[ag]|m3u|flac|spx)" [ps2pdfwr]="!*.@(?(e)ps|pdf)" [harbour]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [lomath]="!*.@(sxm|smf|mml|odf)" [xemacs]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [unlzma]="!*.@(tlz|lzma)" [lowriter]="!*.@(sxw|stw|sxg|sgl|doc?([mx])|dot?([mx])|rtf|txt|htm|html|?(f)odt|ott|odm|pdf)" [vi]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [xetex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [gvim]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [kid3-qt]="!*.@(mp[234c]|og[ag]|@(fl|a)ac|m4[abp]|spx|tta|w?(a)v|wma|aif?(f)|asf|ape)" [xanim]="!*.@(mpg|mpeg|avi|mov|qt)" [portecle]="!@(*.@(ks|jks|jceks|p12|pfx|bks|ubr|gkr|cer|crt|cert|p7b|pkipath|pem|p10|csr|crl)|cacerts)" [oocalc]="!*.@(sxc|stc|xls?([bmx])|xlw|xlt?([mx])|[ct]sv|?(f)ods|ots)" [emacs]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [fbxine]="!*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.part)" [kpdf]="!*.@(?(e)ps|pdf)" [oomath]="!*.@(sxm|smf|mml|odf)" [compress]="*.Z" [iceweasel]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL])|[pP][dD][fF])" [zcat]="!*.@(Z|[gGd]z|t[ag]z)" [unzip]="!*.@(zip|[egjsw]ar|exe|pk3|wsz|zargo|xpi|s[tx][cdiw]|sx[gm]|o[dt][tspgfc]|od[bm]|oxt|epub|apk|ipa|do[ct][xm]|p[op]t[mx]|xl[st][xm]|pyz)" [modplug123]="!*.@(669|abc|am[fs]|d[bs]m|dmf|far|it|mdl|m[eo]d|mid?(i)|mt[2m]|oct|okt?(a)|p[st]m|s[3t]m|ult|umx|wav|xm)" [dvipdfm]="!*.dvi" [oobase]="!*.odb" [zipinfo]="!*.@(zip|[egjsw]ar|exe|pk3|wsz|zargo|xpi|s[tx][cdiw]|sx[gm]|o[dt][tspgfc]|od[bm]|oxt|epub|apk|ipa|do[ct][xm]|p[op]t[mx]|xl[st][xm]|pyz)" [epiphany]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [galeon]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [bzme]="!*.@(zip|z|gz|tgz)" [xfig]="!*.fig" [xdvi]="!*.@(dvi|DVI)?(.@(gz|Z|bz2))" [cdiff]="!*.@(dif?(f)|?(d)patch)?(.@([gx]z|bz2|lzma))" [rgview]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [oowriter]="!*.@(sxw|stw|sxg|sgl|doc?([mx])|dot?([mx])|rtf|txt|htm|html|?(f)odt|ott|odm|pdf)" [netscape]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [acroread]="!*.[pf]df" [makeinfo]="!*.texi*" [kwrite]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [gview]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [qiv]="!*.@(gif|jp?(e)g|tif?(f)|png|p[bgp]m|bmp|x[bp]m|rle|rgb|pcx|fits|pm|svg)" [bzcat]="!*.?(t)bz?(2)" [pdftex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [rpm2cpio]="!*.[rs]pm" [view]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [unxz]="!*.@(?(t)xz|tlz|lzma)" [ly2dvi]="!*.ly" [mozilla]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [modplugplay]="!*.@(669|abc|am[fs]|d[bs]m|dmf|far|it|mdl|m[eo]d|mid?(i)|mt[2m]|oct|okt?(a)|p[st]m|s[3t]m|ult|umx|wav|xm)" [dillo]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [aaxine]="!*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.part)" [dvipdfmx]="!*.dvi" [advi]="!*.dvi" [lzmore]="!*.@(tlz|lzma)" [poedit]="!*.po" [firefox]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL])|[pP][dD][fF])" [gv]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [madplay]="!*.mp3" [gtranslator]="!*.po" [jadetex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [gpdf]="!*.[pf]df" [kghostview]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [pbzcat]="!*.?(t)bz?(2)" [lzcat]="!*.@(tlz|lzma)" [vim]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [dvips]="!*.dvi" [pdfunite]="!*.pdf" [dvitype]="!*.dvi" [realplay]="!*.@(rm?(j)|ra?(m)|smi?(l))" [gqmpeg]="!*.@(mp3|og[ag]|pls|m3u)" [xelatex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [lzegrep]="!*.@(tlz|lzma)" [bunzip2]="!*.?(t)bz?(2)" [znew]="*.Z" [lokalize]="!*.po" [kate]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [dragon]="!*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM|iso|ISO)|+([0-9]).@(vdr|VDR))?(.part)" [pdflatex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [mozilla-firefox]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL])|[pP][dD][fF])" [ooimpress]="!*.@(sxi|sti|pps?(x)|ppt?([mx])|pot?([mx])|?(f)odp|otp)" [uncompress]="!*.Z" [unpigz]="!*.@(Z|[gGdz]z|t[ag]z)" [luatex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [lynx]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [ps2pdf]="!*.@(?(e)ps|pdf)" [mpg321]="!*.mp3" [mpg123]="!*.mp3" [pbunzip2]="!*.?(t)bz?(2)" [kid3]="!*.@(mp[234c]|og[ag]|@(fl|a)ac|m4[abp]|spx|tta|w?(a)v|wma|aif?(f)|asf|ape)" [pdfjadetex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [dvipdf]="!*.dvi" [gharbour]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [texi2html]="!*.texi*" [gunzip]="!*.@(Z|[gGd]z|t[ag]z)" [google-chrome]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL])|[pP][dD][fF])" [okular]="!*.@(okular|@(?(e|x)ps|?(E|X)PS|[pf]df|[PF]DF|dvi|DVI|cb[rz]|CB[RZ]|djv?(u)|DJV?(U)|dvi|DVI|gif|jp?(e)g|miff|tif?(f)|pn[gm]|p[bgp]m|bmp|xpm|ico|xwd|tga|pcx|GIF|JP?(E)G|MIFF|TIF?(F)|PN[GM]|P[BGP]M|BMP|XPM|ICO|XWD|TGA|PCX|epub|EPUB|odt|ODT|fb?(2)|FB?(2)|mobi|MOBI|g3|G3|chm|CHM)?(.?(gz|GZ|bz2|BZ2)))" [slitex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [xzcat]="!*.@(?(t)xz|tlz|lzma)" [timidity]="!*.@(mid?(i)|rmi|rcp|[gr]36|g18|mod|xm|it|x3m|s[3t]m|kar)" [dviselect]="!*.dvi" )
command_not_found_handle () 
dequote () 
quote () 
quote_readline () 
snap_bin_path=/snap/bin
snap_xdg_path=/var/lib/snapd/desktop
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
{ 
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}";
}";
}";
}";
